using ServISData;
using ServISData.Models;
using ServISWebApp.Components.Forms;
using System.Text;

namespace ServISWebApp.Shared.Extensions
{
	public static class AutogeneratedMessageExtensions
	{
		public static string FormatSubject(this AutogeneratedMessage autogeneratedMessage, AuctionSummary auctionSummary)
		{
			autogeneratedMessage.ParseSubject(out string subjectFormat, out Func<AuctionSummary, string>[] subjectArgs);

			var formattedSubject = string.Format(subjectFormat, subjectArgs.Select(x => x(auctionSummary)).ToArray());

			return formattedSubject;
		}

		public static List<string> FormatSubject(this AutogeneratedMessage autogeneratedMessage, List<AuctionSummary> auctionSummaries)
		{
			autogeneratedMessage.ParseSubject(out string subjectFormat, out Func<AuctionSummary, string>[] subjectArgs);

			var formattedSubjects = new List<string>(auctionSummaries.Count);
			foreach (var auctionSummary in auctionSummaries)
			{
				var formattedSubject = string.Format(subjectFormat, subjectArgs.Select(x => x(auctionSummary)).ToArray());
				formattedSubjects.Add(formattedSubject);
			}

			return formattedSubjects;
		}

		public static string FormatMessage(this AutogeneratedMessage autogeneratedMessage, AuctionSummary auctionSummary)
		{
			autogeneratedMessage.ParseMessage(out string messageFormat, out Func<AuctionSummary, string>[] messageArgs);

			var formattedMessage = string.Format(messageFormat, messageArgs.Select(x => x(auctionSummary)).ToArray());
			
			return formattedMessage;
		}

		public static List<string> FormatMessage(this AutogeneratedMessage autogeneratedMessage, List<AuctionSummary> auctionSummaries)
		{
			autogeneratedMessage.ParseMessage(out string messageFormat, out Func<AuctionSummary, string>[] messageArgs);

			var formattedMessages = new List<string>(auctionSummaries.Count);
			foreach (var auctionSummary in auctionSummaries)
			{
				var formattedMessage = string.Format(messageFormat, messageArgs.Select(x => x(auctionSummary)).ToArray());
				formattedMessages.Add(formattedMessage);
			}

			return formattedMessages;
		}

		private static void ParseSubject(this AutogeneratedMessage autogeneratedMessage, out string format, out Func<AuctionSummary, string>[] args)
		{
			string subject = string.IsNullOrEmpty(autogeneratedMessage.Subject) ? 
				autogeneratedMessage.ForWhom.GetDefaultSubject() : autogeneratedMessage.Subject;

			ParseText(subject, out format, out args);
		}

		private static void ParseMessage(this AutogeneratedMessage autogeneratedMessage, out string format, out Func<AuctionSummary, string>[] args)
		{
			string message = string.IsNullOrEmpty(autogeneratedMessage.Message) ?
				autogeneratedMessage.ForWhom.GetDefaultMessage() : autogeneratedMessage.Message;

			ParseText(message, out format, out args);
		}

		private static bool IsAllowedCharInTagBody(char c) => char.IsLetter(c) || c == '_';

		/// <summary>
		/// This method returns the tag in `text` that starts from index `i` (`i` is the index of "#").
		/// After extraction is complete, the `i` is the index of the last character of the tag.
		/// Tag starts with the "#" and consists of letters and "_".
		/// </summary>
		private static string ExtractTag(string text, ref int i)
		{
			var c = text[i];
			var tag = string.Empty; // don't think another StringBuilder is necessary here, I assume tag is short
			do
			{
				tag += c;
				i++; // in the first iteration we skip "#"
				if (i >= text.Length)
				{
					break;
				}
				c = text[i];

			} while (IsAllowedCharInTagBody(c));

			i--; // we decrement i so it points to the last character of the tag

			/* This approach of incrementing i to skip "#" (at the beginning of the method)
			 * and then decrementing i (here at the end) lets us to have multiple tags
			 * following each other, e.g. #tag1#tag2. */
			return tag;
		}

		private static void ParseText(string text, out string format, out Func<AuctionSummary, string>[] args)
		{
			var sb = new StringBuilder();
			var functions = new List<Func<AuctionSummary, string>>();
			int argsCounter = 0;

			for (int i = 0; i < text.Length; i++)
			{
				char c = text[i];
				if (c != '#' || (i + 1) >= text.Length)
				{
					sb.Append(c);
					continue;
				}
				if (!IsAllowedCharInTagBody(text[i + 1]))
				{// its just "#" (an empty tag), not a proper tag (e.g. #abc)
					sb.Append(c);
					continue;
				}

				var tag = ExtractTag(text, ref i);
				if (!AutogeneratedMessageForm.Tags.TryGetValue(tag, out var func))
				{
					throw new Exception($"Error occurred while parsing autogenerated message, tag '{tag}' doesn't exist. " +
						$"(Maybe some typo in tag?)");
				}
				functions.Add(func);

				sb.Append($"{{{argsCounter}}}"); // we substitue tag...
				argsCounter++;
			}

			format = sb.ToString();
			args = functions.ToArray();
		}
	}
}
