using ServISData;
using ServISData.Models;
using ServISWebApp.Components.Forms;
using System.Text;

namespace ServISWebApp.Shared.Extensions
{
    /// <summary>
    /// Provides extension methods for formatting the subject and message body of an <see cref="AutogeneratedMessage"/> 
	/// based on an <see cref="AuctionSummary"/>.
    /// </summary>
    public static class AutogeneratedMessageExtensions
	{
        /// <summary>
        /// Formats the subject of the <paramref name="autogeneratedMessage"/> using 
		/// the specified <paramref name="auctionSummary"/>.
        /// If the subject is empty or null, the default subject 
		/// corresponding to the message's <see cref="AutogeneratedMessage.ForWhom"/> value is used.
        /// </summary>
        /// <param name="autogeneratedMessage">The <see cref="AutogeneratedMessage"/> instance providing 
		/// subject template for formatting.</param>
        /// <param name="auctionSummary">The <see cref="AuctionSummary"/> instance used as data source 
		/// for formatting the subject.</param>
        /// <returns>The formatted subject text.</returns>
        public static string FormatSubject(this AutogeneratedMessage autogeneratedMessage, AuctionSummary auctionSummary)
		{
			var subject = GetSubject(autogeneratedMessage);

			var formattedText = GetFormattedText(subject, auctionSummary);

			return formattedText;
		}

        /// <summary>
        /// Formats the subject of the <paramref name="autogeneratedMessage"/> using 
		/// the specified list of <paramref name="auctionSummaries"/>.
        /// If the subject is empty or null, the default subject 
		/// corresponding to the message's <see cref="AutogeneratedMessage.ForWhom"/> value is used.
        /// </summary>
        /// <param name="autogeneratedMessage">The <see cref="AutogeneratedMessage"/> instance providing 
		/// subject template for formatting.</param>
        /// <param name="auctionSummaries">The list of <see cref="AuctionSummary"/> instances used as data source 
		/// for formatting the subjects.</param>
        /// <returns>The list of formatted subject texts.</returns>
        public static List<string> FormatSubject(
			this AutogeneratedMessage autogeneratedMessage, List<AuctionSummary> auctionSummaries)
		{
			var subject = GetSubject(autogeneratedMessage);

			var formattedTexts = GetFormattedTexts(subject, auctionSummaries);

			return formattedTexts;
		}

        /// <summary>
        /// Formats the message body of the <paramref name="autogeneratedMessage"/> using 
		/// the specified <paramref name="auctionSummary"/>.
        /// If the message body is empty or null, the default message body 
		/// corresponding to the message's <see cref="AutogeneratedMessage.ForWhom"/> value is used.
        /// </summary>
        /// <param name="autogeneratedMessage">The <see cref="AutogeneratedMessage"/> instance used as data source 
		/// for formatting the message body.</param>
        /// <param name="auctionSummary">The <see cref="AuctionSummary"/> instance used for formatting the message body.</param>
        /// <returns>The formatted message body text.</returns>
        public static string FormatMessage(this AutogeneratedMessage autogeneratedMessage, AuctionSummary auctionSummary)
		{
			var message = GetMessage(autogeneratedMessage);

			var formattedText = GetFormattedText(message, auctionSummary);

			return formattedText;
		}

        /// <summary>
        /// Formats the message body of the <paramref name="autogeneratedMessage"/> using 
		/// the specified list of <paramref name="auctionSummaries"/>.
        /// If the message body is empty or null, the default message body 
		/// corresponding to the message's <see cref="AutogeneratedMessage.ForWhom"/> value is used.
        /// </summary>
        /// <param name="autogeneratedMessage">The <see cref="AutogeneratedMessage"/> instance providing 
		/// message body template for formatting.</param>
        /// <param name="auctionSummaries">The list of <see cref="AuctionSummary"/> instances used as data source 
		/// for formatting the message bodies.</param>
        /// <returns>The list of formatted message body texts.</returns>
        public static List<string> FormatMessage(
			this AutogeneratedMessage autogeneratedMessage, List<AuctionSummary> auctionSummaries)
		{
			var message = GetMessage(autogeneratedMessage);

			var formattedMessages = GetFormattedTexts(message, auctionSummaries);

			return formattedMessages;
		}

		private static string GetSubject(AutogeneratedMessage autogeneratedMessage) =>
			string.IsNullOrEmpty(autogeneratedMessage.Subject)
				? autogeneratedMessage.ForWhom.GetDefaultSubject()
				: autogeneratedMessage.Subject;

		private static string GetMessage(AutogeneratedMessage autogeneratedMessage) =>
			string.IsNullOrEmpty(autogeneratedMessage.Message)
				? autogeneratedMessage.ForWhom.GetDefaultMessage()
				: autogeneratedMessage.Message;

		private static bool IsAllowedCharInTagBody(char c) => char.IsLetter(c) || c == '_';

        /// <summary>
        /// This method returns the tag in <paramref name="text"/> that starts from index <paramref name="i"/> 
		/// (<paramref name="i"/> is the index of "#").
        /// After extraction is complete, the <paramref name="i"/> is the index of the last character of the tag.
        /// Tag starts with the "#" and consists of letters and "_".
        /// </summary>
        private static string ExtractTag(string text, ref int i)
		{
			var c = text[i];
			var tag = string.Empty; // don't think another StringBuilder is necessary here, I assume tag is short
			do
			{
				tag += c;
				i++; // in the first iteration we skip "#"
				if (i >= text.Length)
				{
					break;
				}
				c = text[i];

			} while (IsAllowedCharInTagBody(c));

			i--; // we decrement i so it points to the last character of the tag

			/* This approach of incrementing i to skip "#" (at the beginning of the method)
			 * and then decrementing i (here at the end) lets us to have multiple tags
			 * following each other, e.g. #tag1#tag2. */
			return tag;
		}

		private static string GetFormattedText(string textTemplate, AuctionSummary summary)
		{
			var formattedTextBuilder = new StringBuilder();

			for (int i = 0; i < textTemplate.Length; i++)
			{
				char c = textTemplate[i];

				if (c != '#' || (i + 1) >= textTemplate.Length)
				{// its not # (start of tag) or it is # but its the last char in text (so its not a valid tag)
					formattedTextBuilder.Append(c);
					continue;
				}

				if (!IsAllowedCharInTagBody(textTemplate[i + 1]))
				{
					formattedTextBuilder.Append(c);
					continue;
				}

				var tag = ExtractTag(textTemplate, ref i);
				if (!AutogeneratedMessageForm.Tags.TryGetValue(tag, out var valueAccessor))
				{// unknown tag, there is no valueAccessor for this tag
					formattedTextBuilder.Append(tag);
					continue;
				}

				var valueSubstitutedForTag = valueAccessor(summary);
				formattedTextBuilder.Append(valueSubstitutedForTag);
			}

			return formattedTextBuilder.ToString();
		}

		private static List<string> GetFormattedTexts(string textTemplate, List<AuctionSummary> summaries)
		{
			var formattedTexts = new List<string>(summaries.Count);

			foreach (var summary in summaries)
			{
				var formattedText = GetFormattedText(textTemplate, summary);

				formattedTexts.Add(formattedText);
			}

			return formattedTexts;
		}
	}
}
