using ServISData;
using ServISData.Models;
using ServISWebApp.Components.Forms;
using System.Text;

namespace ServISWebApp.Shared.Extensions
{
	public static class AutogeneratedMessageExtensions
	{
		public static string FormatSubject(this AutogeneratedMessage autogeneratedMessage, AuctionSummary auctionSummary)
		{
			var subject = GetSubject(autogeneratedMessage);

			var formattedText = GetFormattedText(subject, auctionSummary);

			return formattedText;
		}

		public static List<string> FormatSubject(this AutogeneratedMessage autogeneratedMessage, List<AuctionSummary> auctionSummaries)
		{
			var subject = GetSubject(autogeneratedMessage);

			var formattedTexts = GetFormattedTexts(subject, auctionSummaries);

			return formattedTexts;
		}

		public static string FormatMessage(this AutogeneratedMessage autogeneratedMessage, AuctionSummary auctionSummary)
		{
			var message = GetMessage(autogeneratedMessage);

			var formattedText = GetFormattedText(message, auctionSummary);

			return formattedText;
		}

		public static List<string> FormatMessage(this AutogeneratedMessage autogeneratedMessage, List<AuctionSummary> auctionSummaries)
		{
			var message = GetMessage(autogeneratedMessage);

			var formattedMessages = GetFormattedTexts(message, auctionSummaries);

			return formattedMessages;
		}

		private static string GetSubject(AutogeneratedMessage autogeneratedMessage) =>
			string.IsNullOrEmpty(autogeneratedMessage.Subject)
				? autogeneratedMessage.ForWhom.GetDefaultSubject()
				: autogeneratedMessage.Subject;

		private static string GetMessage(AutogeneratedMessage autogeneratedMessage) =>
			string.IsNullOrEmpty(autogeneratedMessage.Message)
				? autogeneratedMessage.ForWhom.GetDefaultMessage()
				: autogeneratedMessage.Message;

		private static bool IsAllowedCharInTagBody(char c) => char.IsLetter(c) || c == '_';

		/// <summary>
		/// This method returns the tag in `text` that starts from index `i` (`i` is the index of "#").
		/// After extraction is complete, the `i` is the index of the last character of the tag.
		/// Tag starts with the "#" and consists of letters and "_".
		/// </summary>
		private static string ExtractTag(string text, ref int i)
		{
			var c = text[i];
			var tag = string.Empty; // don't think another StringBuilder is necessary here, I assume tag is short
			do
			{
				tag += c;
				i++; // in the first iteration we skip "#"
				if (i >= text.Length)
				{
					break;
				}
				c = text[i];

			} while (IsAllowedCharInTagBody(c));

			i--; // we decrement i so it points to the last character of the tag

			/* This approach of incrementing i to skip "#" (at the beginning of the method)
			 * and then decrementing i (here at the end) lets us to have multiple tags
			 * following each other, e.g. #tag1#tag2. */
			return tag;
		}

		private static string GetFormattedText(string textTemplate, AuctionSummary summary)
		{
			var formattedTextBuilder = new StringBuilder();

			for (int i = 0; i < textTemplate.Length; i++)
			{
				char c = textTemplate[i];

				if (c != '#' || (i + 1) >= textTemplate.Length)
				{// its not # (start of tag) or it is # but its the last char in text (so its not a valid tag)
					formattedTextBuilder.Append(c);
					continue;
				}

				if (!IsAllowedCharInTagBody(textTemplate[i + 1]))
				{
					formattedTextBuilder.Append(c);
					continue;
				}

				var tag = ExtractTag(textTemplate, ref i);
				if (!AutogeneratedMessageForm.Tags.TryGetValue(tag, out var valueAccessor))
				{// unknown tag, there is no valueAccessor for this tag
					formattedTextBuilder.Append(tag);
					continue;
				}

				var valueSubstitutedForTag = valueAccessor(summary);
				formattedTextBuilder.Append(valueSubstitutedForTag);
			}

			return formattedTextBuilder.ToString();
		}

		private static List<string> GetFormattedTexts(string textTemplate, List<AuctionSummary> summaries)
		{
			var formattedTexts = new List<string>(summaries.Count);

			foreach (var summary in summaries)
			{
				var formattedText = GetFormattedText(textTemplate, summary);

				formattedTexts.Add(formattedText);
			}

			return formattedTexts;
		}
	}
}
