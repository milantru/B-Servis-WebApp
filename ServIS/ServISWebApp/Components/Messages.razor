@inject IConfiguration config
@inject EmailManager emailManager
@using MailKit.Net.Imap;
@using MailKit;
@using MimeKit;

<div class="my-container">
	<h3>Správy</h3>

	@if (messageSettingsClosed)
	{
		<div class="top-right">
			<CogIconButton OnClick="() => messageSettingsClosed = false" />
		</div>

		@if (Threads is null)
		{
			<p>Načítava sa...</p>
		}
		else
		{
			@if (CurrentlyChosenThread is null)
			{
				<ThreadsView @bind-Threads="Threads"
							 OnThreadClick="ChangeToThreadView"
							 OnReload="LoadThreadsAsync"
							 EmailManager="@emailManager" />
			}
			else
			{
				<ThreadView @bind-Thread="@CurrentlyChosenThread"
							OnSent="OnSent"
							OnBack="() => ChangeToThreadView(null)"
							OnDelete="DeleteThread"
							EmailManager="@emailManager" />
			}
		}
	} 
	else
	{
		<div class="top-right">
			<BackIconButton OnClick="() => messageSettingsClosed = true" />
		</div>

		<MessageSettings />
	}
</div>

@code {
	private bool messageSettingsClosed = true;

	private List<Thread> Threads { get; set; } = null!;
	private Thread? CurrentlyChosenThread { get; set; }

	protected override async Task OnInitializedAsync()
	{
		await base.OnInitializedAsync();

		await LoadThreadsAsync();
	}

	private void ChangeToThreadView(Thread? thread)
	{
		CurrentlyChosenThread = thread;
	}

	private async Task LoadThreadsAsync()
	{
		Threads = await emailManager.UpdateThreadsAsync(Threads ?? new());

		if (CurrentlyChosenThread is not null)
		{
			/* If we are (re)loading threads and currently have some thread chosen,
				* we want to find its newer version and "update" it (replace old for the newer version).
				* That's the reason for this if.
				* Additionaly, here is used `FirstOrDefault` and not just `First` because there might
				* be (temporary) moment when currently chosen thread does NOT exist (i.e. when we are deleting it,
				* in this situation it is ok to return null (default) because after deletion we would set
				* CurrentlyChosenThread to null anyway). */
			CurrentlyChosenThread = Threads.FirstOrDefault(t => t.Id == CurrentlyChosenThread.Id);
		}
	}

	private async Task OnSent(Thread threadFromWhichWasMessageSent)
	{
		await LoadThreadsAsync();

		var updatedThread = Threads.First(t => t.Id == threadFromWhichWasMessageSent.Id);

		/* Sometimes after replying to a message, the reply message is NOT marked as read/seen.
		 * That is the reason we check here after sending the message and reloading messages if
		 * the newest message (the reply) is marked as read. If not, we mark it as read. */
		if (!updatedThread.IsRead)
		{
			var updatedThreadLastMessage = updatedThread.Messages.Last();

			var markMessageAsReadTask = emailManager.MarkEmailAsReadAsync(updatedThreadLastMessage);

			updatedThread.IsRead = true;

			await markMessageAsReadTask;
		}
	}

	private void DeleteThread(Thread thread)
	{
		Threads.Remove(thread);
	}
}
