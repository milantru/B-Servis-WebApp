@inject IConfiguration config
@using MailKit.Net.Imap;
@using MailKit;
@using MimeKit;

<div class="my-container">
	<h3>Správy</h3>

	@if (Threads is null)
	{
		<p>Načítava sa...</p>
	}
	else
	{
		@if (CurrentlyChosenThread is null)
		{
			<ThreadsView @bind-Threads="Threads"
						 OnThreadClick="ChangeToThreadView"
						 OnReload="LoadThreadsAsync"
						 EmailManager="@emailManager" />
		}
		else
		{
			<ThreadView Messages="@CurrentlyChosenThread.Messages"
						OnSent="OnSent"
						OnBack="() => ChangeToThreadView(null)"
						OnReloadRequest="LoadThreadsAsync"
						EmailManager="@emailManager" />
		}
	}
</div>

@code {
	private EmailManager emailManager = null!;
	//private Timer timer = null!;

	private List<Thread> Threads { get; set; } = null!;
	private Thread? CurrentlyChosenThread { get; set; }

	protected override async Task OnInitializedAsync()
	{
		await base.OnInitializedAsync();

		emailManager = new EmailManager(config["EmailAddress"], config["EmailAppPassword"]);

		await LoadThreadsAsync();

		//timer = new(async (_) => {
		//	await InvokeAsync(async () =>
		//	{
		//		await LoadThreadsAsync();
		//		Console.WriteLine("HUEAWUEUAWEUWAUEAWUEAW");
		//		StateHasChanged();
		//	});
		//}, null, 10_000, 10_000);
	}

	private void ChangeToThreadView(Thread? thread)
	{
		CurrentlyChosenThread = thread;
	}

	private async Task LoadThreadsAsync()
	{
		Threads = await emailManager.GetThreadsAsync();

		if (CurrentlyChosenThread is not null)
		{
			/* If we are (re)loading threads and currently have some thread chosen,
				* we want to find its newer version and "update" it (replace old for the newer version).
				* That's the reason for this if.
				* Additionaly, here is used `FirstOrDefault` and not just `First` because there might
				* be (temporary) moment when currently chosen thread does NOT exist (i.e. when we are deleting it,
				* in this situation it is ok to return null (default) because after deletion we would set
				* `CurrentlyChosenThread` to null anyway).
				*/
			CurrentlyChosenThread = Threads.FirstOrDefault(t => t.Id == CurrentlyChosenThread.Id);
		}
	}

	private async Task OnSent()
	{
		await LoadThreadsAsync();

		/* Sometimes after replying to message, the reply message is NOT marked as read/seen.
		 * That is the reason we check here after sending the message and reloading messages if
		 * the newest message (the reply) is marked as read. If not, we mark it as read.
		 * Additionally, it should be OK to use `!` here because this is called only when
		 * replying to message in thread and that is possible only when in thread view, meaning
		 * `CurrentlyChosenThread` is not null.
		 */
		var lastMsg = CurrentlyChosenThread!.Messages.Last();
		if (lastMsg.Flags.HasValue && !lastMsg.Flags.Value.HasFlag(MessageFlags.Seen))
		{
			await emailManager.MarkEmailAsReadAsync(lastMsg.UniqueId);

			/* After we sent a request to mark message as read we would like to change `Flag` property
			 * to seen here in code as well... However that's not as simple as reassigning the variable
			 * because `Flag` property has only getter, I didn't find any way to change it in code.
			 * The only way I know of is to request for new (updated) one. And that's what we do here.
			 */
			var lastMsgIndex = CurrentlyChosenThread!.Messages.Count - 1;
			var lastMsgUpdated = await emailManager.GetMessageSummaryAsync(lastMsg.UniqueId);
			CurrentlyChosenThread!.Messages[lastMsgIndex] = lastMsgUpdated;
		}
	}
}
