\chapter{Analýza}

TBA: Uvodna rec o tom ako si ideme rozmysliet naplenenie poziadavok z uvodu a zaroven z casti Navrh UI (predosla kapitola).

\section{Výber typu aplikácie}

Kvôli požiadavke P10~(\ref{dostupnost}) dáva dobrý zmysel vytvoriť náš systém ako webovú aplikáciu~-- vyriešime tým problém s distribúciou softvéru k (aj potenciálne novým) zákazníkom, a takisto vyriešime problém s potenciálne zastaralými počítačmi vo firme. Statická stránka by nám nestačila nakoľko chceme administrátorom umožniť dynamickú zmenu obsahu.

\section{Výber jazyka a~frameworku}

Teraz keď už vieme, že ideme vytvárať webovú aplikáciu si musíme rozmyslieť v akom jazyku a pomocou akého frameworku ju budeme vyvíjať.

\subsection{Výber backend jazyka}

Na tvorbu webovej aplikacie s~bohatym UI sa hodi high level jazyk, napr Java alebo C\#. Autor ovlada C\#, preto volime C\# a platformu .NET, ktora je s nim spojena.

\subsection{SPA}

SPA by nam pomohli s interktivitou nasho UI (tym sa mysli napr zobrazovanie/schovavanie formov alebo obsah zorbazovany/schovavany podla toho aky uzivatel je prihlaseny a HLAVNE odpocet aukcnych ponuk), kedze kod je vykonavany rychlejsie lebo je vykonavany priamo na klientovi.

Aplikacia by mohla bezat aj offline, ale to pre nas neni podstatne.

Nevyhodou je ze by sme museli vytvarart nejake bezpecne API, napr pre pracu s databazou.

Takisto je nevyhodou dlhsi prvotny nacitavaci cas (lebo cakame kym sa zdrojaky stiahnu), ktory by mohol odradit novych potencialnych zakaznikov.

Prikladom tohto by boli napr JS frameworky ako React, Angular atď alebo C\#ový Blazor WebAssembly.

\subsection{Klasické webové aplikácie}

Zdá sa že toto by bolo dobre pretože kód je vykonavany na serveri, preto mozeme priamo pracovat s databazou, nemusime vytvarat api.

Uzivatelovi sa serviruje len HTML, CSS, JS, takze nemali by mat starsie pocitace problem.

Navyse kvoli tomu su CEO friendly, co znamena ze search-enginy ako napr Google ich vie lahsie najst, a ich prvotny nacitavaci cas je rychly, co je tiez dobre pre ziskavanie novych zakaznikov.

ALE vracaju sa zo serveru cele stranky... No a ked sa pozrieme na nase UI, tak vidime ze je celkom interkativne a castokrat meni len cast aplikacie, nie celu (znovu moze uviest priklady ako v SPA).

Tento problem by sa mozno dal vyriesit napr. pomocou nejakych featur v ASP.NET MVC, ale ako si mozme v casti Navrh UI vsimnut, tak viacero casti aplikacie vyzera rovnako, a preto by sa nam hodilo, ak by sme tieto rovnake/podobne casti mohli zadefinovat raz a potom vyuzivat na viacerych miestach. ASP.NET MVC nam umoznuje definovat celu stranku ale nie len cast stranky~-- komponentu. Existuje este jedna moznost ktora nam prinesie vyhody SPA, klasickych webovych aplikacii a zaroven nam umozni definvoat spominane komponenty.

\subsection{Blazor Server}

Existuej však ešte jedna možnosť~--Blazor Server. Tento framework je niečo ,,medzi``. Poskytuje výhody klasickej webovej aplikacie v tom zmysle, že má rýchle prvotne nacitanie stranky, serviruje uzivatelom iba HTML, CSS, JS. Ďalšou výhodou je že kód je iba na serveri preto mozme komunikovat s databazou priamo a nemusime vytvarat separatne API. Ale zároven nam poskytuje výhody SPA interaktivity preto, pretoze pri zmene UI sa neposiela zo serveru cela stranka ale iba zmeny. Nie je to síce az tak rýchle ako keby kod bezal u clienta ale kedze my netvorime nejaku narocnu real timovu aplikaciu, tka nam to staci. Zaroven by bolo nevyhodou to ze sa vytvara zataz na server, ale kedze program je urceny pre male firmy, ktore nemaju az tak vysoky pocet uzivatelov tak nam to nevadi, plus dalsou nevyhodou by mohlo byt ze nemoze apliakcia bezat offline, ale to nam takisto nevadi, to sme ani nechceli.

Navyše kvôli výberu tohto frameworku budeme môcť písať aj forntend, aj backend v jazyku C\#.

\section{Voľba databázy}

TODO

\subsection{Návrh relačného modelu databázy}

TODO

\subsection{Voľba typu databázy a databázového servera}

TODO

\subsection{ORM}

TODO

\section{Aukcia- odpočet a vyhodnocovanie}

TODO

---

PO TADE JE NOVY TEXT

---

TBA: Ako vidíme tak potrebujeme bohaty frontend, na to sa hodi napr JavaScriptové frameworky ako su React, Vue atd., a takisto nam nestaci Backend as a Service (ktory poskytuje napr Amazon...), lebo napr kvoli vyhodnocovaniu aukcie, takze preto vlastny backend. Na tvorbu webovej aplikacie s bohatym UI sa hodi high level jazyk, napr Java alebo C\#. Autor ovlada C\#, preto volime C\# a platformu .NET, ktora je s nim spojena. Backend by sme mohli implementovat pomocou frmeworku ASP.NET MVC. No este existuje ina varianta a tou je Blazor. Ten nam umozni vyuzivat komponenty (to sa nam hodi napr. aj kvoli implementácii odpočtu) a takisto nám umožní písať frontend aj backend v rovnakom jazyku -- C\#.

Blazor poskytuje viaceo hosting modelov a v dobe vyberu technologii existovali dva -- Blazor WebAssebmly a Blazor Server. Blazor WebAssembly funguje skor na sposob SPA, kde logika aplikacie bezi na klientskom pocitaci vo webovom prehliadaci, a su s nim spojene nejake problemy [vymenujem, napr to ze search engingy mozu mat problem s nim, P10 aby to uzivatelom rozbehol pc, aby nebol zastaraly prehliadac, prvotne nacitanie trva dlho (lebo stahuje zdrojaky) co by mohlo potencialnych zakaznikov odradit, a tiez nejake WebApi na server by sme museli vytvarat). Naproti Blazor Server sa podoba skor tradicnemu web app pristupu a hodi sa nam viac lebo je CEO-friendly, kod bezi na servery a uzivatel dostane len HTML, CSS, JS, preto aj starsie pc by nemali mat problem s rozbehnutim, a takisto nema preto problem s dlhym prvotnym nacitanim, a navyse nemusime vytvarata WebApi.

Preto si volime C\# (.NET) a Blazor Server.


---------



V~tejto kapitole sa zamyslíme nad tým, ako splniť požiadavky definované v~Úvode~(\ref{poziadavky}).

Pre~splnenie požiadavky P1 dáva veľmi dobrý zmysel vytvoriť naše riešenie ako webovú aplikáciu. Týmto spôsobom sa nemusíme starať o~distribúciu programu k~užívateľom. Stačí ak má zákazník~(resp. admin) pripojenie na~internet.

Je síce pravda, že voľba webovej aplikácie zahŕňa i~voľbu hostingu. A~ten nemusí byť lacný. To by mohlo byť v~rozpore s~P2. Ale je potrebné dodať, že ak by sme zvolili klasickú desktopovú aplikáciu, tak by sme ju museli nejakým spôsobom dodať zákazníkovi. A~to by bolo nepraktické, prípadne by mohlo stáť takisto nejaké peniaze. Navyše práve webová aplikácia má~potenciál pomôcť firme tak, že ju zákazník objaví pri surfovaní internetu.

Pre splnenie~P4,~P5~a~P8 je jasné, že budeme potrebovať databázu. A~to na~to, aby si firmy vedeli samé tvoriť ponuku, ktorú si do databázy uložia. Po~príchode zákazníka bude možné ponuku z~databázy načítať a~zobraziť. Podobne v~prípade~P8. Keď sa užívateľ zaregistruje, jeho údaje sa uložia v~databáze a~pri prihlásení sa z~nej prečítajú a~môžu použiť pre vyplnenie formulárov podľa potreby.

Znova sa vrátim k~P5. Kedže ide o aukciu, budeme potrebovať nejaký mechanizmus, ktorý by vedel zabezpečiť odpočet, a~takisto vyhodnotenie aukcie na~pozadí. Taktiež si musíme rozmyslieť, ako sa má aukcia správať v~rôznych situáciách.

Na to, aby sme splnili P6, musí byť náš softvér schopný posielať správy. Z~podmienky P3 usudzujeme, že nikto nebude pri softvére sedieť, a~teda posielanie dopytov by nemalo mať povahu četu. Posielanie správ bude prebiehať prostredníctvom emailov. To nám vytvára novú požiadavku na~softvér. Aby administrátor nemusel preklikávať medzi svojou emailovou schránku a~naším systémom, bolo by dobre integrovať jeho schránku priamo do systému.

\section{Voľba typu aplikácie, jazyka a frameworku}

Po prejdení požiadaviek vieme, že chceme vytvoriť webovú aplikáciu s~bohatým uživateľským rozhraním, ktorá by bola schopná posielať a~prijímať správy, pracovať s~databázou, umožnila nám autentikáciu a~autorizáciu, a~taktiež vykonávať prácu na~pozadí. Pre túto úlohu sa hodia vysokoúrovňové jazyky, ako sú napríklad C\# alebo Java\dots Na~základe autorových skúseností si volíme jazyk C\# a platformu .NET, ktorá je s~ním spojená.

Platforma .NET nám pre vývoj webových aplikácií poskytuje framework\\ASP.NET alebo Blazor. Obe frameworky sú si podobné. Rozdiel náj\-de\-me v~tom, že Blazor umožňuje vytváranie komponent. Komponent si môžeme predstaviť ako logickú časť stránky (napr. tabuľka, tlačidlo\dots). Po~zadefinovaní komponentu ho~vieme „recyklovať“. Tým myslím to, že ho môžeme použiť na viacerých miestach na webe. Na~každom mieste sa bude správať a~vyzerať rovnako (príp.~vie\-me  jeho správanie meniť pomocou parametrov). Táto myšlienka komponentov sa autorovi páči, dobre sa s~ňou pracuje a~neskôr si ukážeme ako nám pomôže vyriešiť problém s odpočtom.

Blazor poskytuje viacero hosting modelov. V~čase rozhodovania existovali dva: Blazor WebAssembly a Blazor Server. Výber WebAssembly by zahŕňal niekoľko problémov. Pri~prvotnej návšteve stránky sa musia klientovi stiahnuť zdrojové kódy aplikácie. To môže chvíľu trvať a~mohlo by to odradiť nových potenciálnych zákazníkov. V~prípade Blazor Server tento problém nemáme, pretože kód beží na~serveri a~užívateľovi sa servíruje už len prerenderovaný HTML, CSS, JavaScript kód stránky. Z~rovnakého dôvodu sú weby vytvorené Blazor Ser\-ve\-rom SEO-friendly (čo znamená, že sú dohľadateľné vyhľadávačmi, akým je napríklad~Google). V~prípade WebAssembly môžu mať vyhľadávače problém. Na to, aby sa dostali k obsahu stránky si musia obsah vygenerovať zo stiahnutých zdrojových kódov. Ale  to môžu mať zakázané z~bezpečnostných dôvodov alebo toho nemusia byť schopné. V~súčasnosti webové prehliadače (Google Chrome, Mozilla Firefox, \dots) podporujú WebAssembly. Ale autor pozorovaním zistil, že vo~firmách sa zvyknú využívať staré počítače s~potenciálne starým softvérom. Takže hrozí, že by sme mali problém WebAssembly rozbehnúť. Kvôli spomenutým dôvodom si volíme Blazor Server.

\section{Návrh systému}

V Úvode sme rozhodli, že náš systém je webová aplikácia, ktorá pracuje s~databázou. Webová aplikácia funguje ako rozhranie pre interakciu s~užívateľmi. Databázu potrebujeme kvôli perzistencii dát. Ako vidíme, obe časti poskytujú vlastnú funkcionalitu. Ak tieto časti oddelíme, pomôžeme rozšíriteľnosti systému.

Keď už vidíme, že systém je zložený z~dvoch častí, poďme si rozmysllieť ako budú spolu interagovať. Webová aplikácia potrebuje pre svoje fungovanie dáta. Tejto závislosti sa nezbavíme. Lenže dátova časť nepotrebuje webovú aplikáciu pre svoje fungovanie. Závislosť z~tejto strany neexistuje.

Majme preto dva projekty: ServISData a ServISWebApp. ServISData slúži ako dátová časť, ktorá je nezávislá a~ServISWebApp poslúži ako webová aplikácia, ktorá je závislá na dátach z projektu ServISData. Architektúru demonštruje obrázok~\ref{architektura systemu}.

\begin{figure}[H]\centering
\includegraphics[width=140mm]{../img/architektura systemu}
\caption{Architektúra systému (predstavuje závislosť ServISWebApp od ServISData).}
\label{architektura systemu}
\end{figure}

\section{Voľba databázy}

Vieme, že náš systém potrebuje pre splnenie podmienok~P4, P5 a~P8 databázu. V tejto kapitole si vyberieme typ databázy, databazový server a~rozoberieme si aké entity potrebujeme.

\subsection{Návrh relačného modelu databázy}
\label{navrh relacneho modelu databazy}

Z P4 vieme, že potrebujeme entity pre bagre a~prídavné zariadenia. Niekoho by mohlo napadnúť spojiť obe entity do~jednej, ale to my nespravíme. Ide o~rozdielne entity, ktoré môžu uchovávať rozdielne informácie (a~ako neskôr v~texte uvidíme, skutočne budú uchovávať rozdielne dáta).

Kedže ide o~ponuku, ktorú chceme prezentovať zákazníkom, chceme okrem textových údajov prezentovať položku, či už stroj alebo~prídavné zariadenie, pomocou fotky. A~nie jednej (predpokladám, že položku budú chcieť firmy predviesť zákazníkom z viacerých uhlov). Znovu by niekomu mohlo napadnúť, že by bol dobrý nápad zlúčiť entitu fotky stroja s~entitou fotky prídavného zariadenia. Ale tieto veci nie sú totožné. Ak by sme entity zlúčili (a~mali teda iba 1 entitu pre~fotku všeobecne), tak by existovala možnosť priradiť fotku prídaného zariadenia stroju (a~naopak). Ale to je nesprávne. Preto znova vytvoríme dve entity. Jedna bude fotka stroja, druhá bude fotka prídavného zariadenia. Pre fotku stroja platí, že patrí práve jednému stroju. Stroj môže mať viacero fotiek. Analogicky platí pre prídavné zariadenia a~ich fotky.

Pri strojoch sa ešte zastavíme. Existujú rôzne značky strojov (napr. Locust, Eurocomach,\dots), a takisto rôzne ketegórie strojov (napr. šmykom riadené nakladače, pásové bagre,\dots). Ďalej v texte, keď budem používať spojenie typ stroja, tak tým myslím kombináciu značky stroja a kategórie stroja. Každý typ stroja sa môže líšiť druhom a formou údajov. Napríklad typ A má hmotnosť ako vlastnosť, ktorú chceme spolu so zbytkom údajov zobraziť užívateľovi. Ďalej typ B má namiesto hmotnosti údaj o výške stroja. Existujú údaje (ako sú napr. meno a opis stroja), ktoré existujú pre každý stroj. Ale takisto existujú údaje, ktoré sa líšia v závislosti od typu stroja. Takýmito údajmi sú vlastnosti stroja. Ako budeme tieto premenlivé údaje ukladať? Jedno z riešení, ktoré by nás mohlo napadnúť je vytvoriť rodičovskú entitu, ktorá by obsahovala údaje spoločné pre všetky typy strojov. A v entitách, ktoré by dedili od rodičovskej triedy by sme dodefinovali premenlivé vlastnosti. Toto riešenie by pravdepodobne fungovalo, lenže má zásadnú nevýhodu. Zakaždým keď si firma zmyslí, že potrebuje nový typ stroja, by entita musela byť manuálne doprogramovaná. Ale kedže my chceme systém navrhnúť všeobecne tak, aby si každá firma vedela zadefinovať vlastnú ponuku strojov, volíme inú alternatívu. Vytvoríme si entitu pre typ stroja. Každý stroj bude nejakého typu. Každý typ obsahuje údaj o~značke a~kategórii. Značka a~kategória sú tiež ďalšími entitami. Typ stroja určuje, akého typu budú vlastnosti konkrétneho stroja. Takže budeme potrebovať entitu typ vlastnosti stoja. Tá obsahuje údaje: názov vlastnosti (napr. hmotnosť, výška,\dots) a~typ hodnoty vlastnosti (napr. číslo, text,\dots). Teda admin bude môcť priradiť typu stroja akého typu bude mať konkrétny stroj vlastnosti.

Stroj vie svoj typ, a~ten vie aké (akého typu) má konkrétny stroj vlastnosti. To, čo ešte nevieme, sú konkrétne hodnoty vlastností stroja. Dovolím si vysvetliť na~príklade. Momentálne máme informáciu o~tom, že konkrétny stroj~S, typu~T, má vlasnosť hmotnosť, ale stále nevieme konkrétnu hodnotu, teda stále nevieme koľko váži. Preto vytvoríme entitu reprezentujúcu vlastnosť stroja. Táto entita vie, akého je typu. A~takisto v~sebe uchováva konkrétnu hodnotu vlastnosti (v~kontexte príkladu, uchováva v~sebe váhu stroja). Každý stroj má v~sebe toľko vlastností, koľko ich je zadefinovaných v~jeho type.

Teraz sa vráťme k~prídavným zariadeniam. Každé prídavné zariadenie má, podobne ako stroj, takisto svoju značku a~patrí do nejakej kategórie. Navyše má oproti strojom aj údaj o~tom, pre akú kategóriu strojov je zariadenie vytvorené. Avšak na rozdiel od~predošlého prípadu so~strojmi, sa tento prípad líši v~tom, že každé prídavné zariadenie, bez ohľadu na~kombináciu typu, kategórie a~kategórie stroja, má druh a~formu údajov rovnakú. Takže stačí ak vytvoríme entitu pre~značku a~kategóriu prídavného zariadenia (entitu pre kategóriu stroja už máme) a~entita reprezentujúca prídavné zariadenie si bude v~sebe držať informáciu o~tom, akej je značky, kategórie a~pre akú kategóriu strojov je vytvorená.

Aby sme splnili P5, budeme potrebovať entitu reprezentujúcu aukčnú ponuku. Aukčná ponuka bude držať informáciu o~tom, aký stroj je v~dražbe. A~takisto údaje o~ponuke (napr. vyvolávacia cena, koniec aukcie,\dots).

No okrem udržania údajov o~aukčnej ponuke a~draženom stroji, si musíme zapamätať i~údaje o~ponukách užívateľov, ktorý sa do~aukcie zapojili. Preto si vytvoríme entitu reprezentujúcu ponuku užívateľa. Bude v~sebe niesť údaje o~tom, ktorý úžívateľ ponúkol sumu, v~akej výške a~pre ktorú aukčnú ponuku.

Entitu užívateľa som načal už v~prechádzajúcom odstavci. Túto entitu skutočne budeme potrebovať a~to aj kvôli splneniu P8. Údaje užívateľov musíme pri~registrácii uchovať, aby sme nimi vedeli predvypĺniť formuláre, a~takisto aby sme vedeli vytvoriť prihlasovanie.

Čítateľ by mohol navrhnúť, že pre splnenie P6 budeme potrebovať entitu reprezentujúcu správy. Toto riešenie by mohlo fungovať, ale ako si neskôr ukážeme, existuje aj iné riešenie. Také, ktoré nám (okrem iného, ale detailnejšie rozobranie príde neskôr) ušetrí úložisko v~databáze. Preto entitu pre správy nevytvárame.

Pre splnenie P7 si vytvoríme entitu, ktorá bude reprezentovať náhradné diely stroja. Každý náhradný diel bude niesť informáciu o~tom, v~ktorých strojoch sa nachádza. A~každý stroj bude vedieť aké diely obsahuje. Každý náhradný diel obsahuje katalógové číslo. Toto číslo je unikátne medzi strojmi, a~preto by mohlo byť použité ako primárny kľúč entity. Ale autor sa z opatrnosti a~kvôli konzistencii (každá entita má id) rozhodol využiť ako primárny kľúč id i~pri náhradných dieloch.

Hlavným predmetom predaja sú stroje. A~preto chceme aby prvé, čo zákazník po~príchode na~stránku uvidí bola ponuka strojov. Takže ešte budeme potrebovať entitu na~reprezentáciu hlavnej ponuky. Táto entita vie aký typ strojov ponúka, a~zároveň obsahuje reprezentatívnu fotku a~opis strojov daného typu.

Pre detailnejšiu predstavu môžeme návrh vidieť na~obrázku~\ref{relacny model uml}.

\begin{figure}[H]\centering
\includegraphics[width=140mm]{../img/relacny model uml}
\caption{Relačný model databázy.}
\label{relacny model uml}
\end{figure}

Pozorný čítateľ si mohol všimnúť, že na~obrázku existuje entita, ktorú sme ešte nespomenuli. Ide o~entitu reprezentujúcu automaticky generované správy. Na~dôvod jej existencie sa pozrieme neskôr. Zatiaľ len~prezradím, že táto entita sa využije pri fungovaní aukcie.

\subsection{Voľba typu databázy a databázového servera}

Kvôli tomu, že naše dáta majú presne definovanú štruktúru, si volíme relačnú databázu. Tá nám poskytne rýchly prístup k~dátam, a~takisto zaručí ich neporušenosť. Ďalším plusom je, že autor má s~relačnými databázami trochu viac skúseností, než s~NoSql databázami.

Čo sa týka databázového servera, tak si najprv poďme rozmyslieť, čo od~neho budeme vyžadovať. Kvôli P2 chceme, aby bol server (v~najlepšom prípade) bezplatný. Taktiež musí byť kompatibilný s~platformou .NET. Tieto požiadavky spĺňajú servery: Microsoft SQL Server, Oracle Database a~MySQL. V~prípade prvých dvoch serverov je síce pravda, že poskytujú aj bezplatnú verziu, ale tie sú obmedzené na~kapacitu. Ale aj napriek obmedzeniu je kapacita dosť veľká. V~prípade Community verzie MySql takéto obmedzenie kapacity nemáme žiadne. V~budúcnosti, ak by sa firme darilo a~získala by viacej zákazníkov, prípadne rozšírila ponuku, by sa nám mohla neobmedzená kapacita servera hodiť. Preto si volíme MySql.

\subsection{ORM}

Keď už máme vybraný databázový server, poďme si rozmyslieť ako s~ním budeme pracovať. Potrebujeme vytvoriť databázu s~tabuľkami, vkladať, editovať, čítať a~mazať dáta. Všetky tieto úkony by sme mohli vykonať tak, že budeme písať kód s SQL syntaxou. Ale keďže autor nemá veľa skúseností s~jazykom SQL, prichádza do úvahy využiť nejaký z~ORM frameworkov (z~ang. object relational mapping). Asi najznámejšími na~platforme .NET sú: Dapper a~Entitfy~Framework~Core. Využívanie frameworku Dapper zahŕňa písanie SQL kódu. Pretože sa snažíme obmedziť písanie SQL kódu, nedáva zmysel si vybrať Dapper. Našou voľbou je preto Entity Framework Core. Konkrétne s~prístupom založeným na~kóde (anglicky code first approach). To znamená, že entity z~relačného modelu najprv napíšeme do~C\# kódu ako triedy a z~nich Entity~Framework~Core vytvorí tabuľky databázy.

\section{Aukcia- odpočet a vyhodnocovanie}

Ako už bolo skôr v~texte spomenuté, budeme potrebovať nejaký mechanizmus, ktorý zvládne vykonávať odpočet do~konca každej aukčnej ponuky, a~takisto aby ju po~skončení vedel vyhodnotiť.

Odpočet by sme mohli implementovať tak, že by sme si vytvorili inštanciu triedy \verb|Timer|\footnote{\url{https://learn.microsoft.com/en-us/dotnet/api/system.timers.timer?view=net-8.0}} pre~každú aukčnú ponuku. Každá z~inštancií by každú sekundu odpálila event, pri~ktorom by došlo k~prerenderovaniu komponentu s~časom do~skončenia ponuky. Toto riešenie by síce fungovalo, ale je to mrhanie zdrojmi. Stačí nám jeden \verb|Timer|. Na~jeho event \verb|Elapsed| si každý komponent s~odpočtom zaregistruje metódu na~prerenderovanie. Týmto spôsobom sa nám podarí ušetriť zdroje, ale vyskytá sa otázka. Kde bude inštancia triedy \verb|Timer| uložená? Prirodzenou odpoveďou by bolo, že ju uložíme do~rodičovského komponentu. Limitácia tohto riešenie spočíva v~tom, že ak budeme potrebovať vykonať nejakú operáciu periodicky každú sekundu, ale v~komponente, ktorá sa nenachádza v~rodičovi s~triedou \verb|Timer|, tak nemáme prístup k~triede \verb|Timer|. Lepším riešením bude presunúť \verb|Timer| do~nového vlákna, ktoré bude bežať na~pozadí. Takýmto spôsobom si môžeme kedykoľvek a~odkiaľkoľvek registrovať periodické operácie.

Tu by som sa ešte rád zastavil a vrátil k~poznámke z~úvodu, kedy som spomenul, že komponenty nám pomôžu vyriešiť problém s~odpočtom. Vieme, že kvôli odpočtu dôjde každú sekundu k prerenderovaniu stránky. No určite nechceme, aby sa nám každú sekundu prerenderovávala celá stránka (resp.~hľadali zmeny na~celej stránke). Ak izolujeme odpočet do~samostatného komponentu, prerenderovanie sa vykoná iba v~ňom. Zbytok stránky to neovplyvní.

Ďalej si potrebujeme rozmyslieť ako bude prebiehať vyhodnocovanie aukcie. Náš systém bude fungovať tak, že užívateľ (ak má záujem o~dražený stroj) odošle svoju~ponúkanú sumu. Tá sa uloží v~databáze. Potrebujeme mechanizmus, ktorý by sledoval aukčné ponuky. Ak by uvidel, že nejaká z~ponúk už skončila, tak ju vyhodnotí. Periodické sledovanie aukčných ponúk je dlhodobo bežiaca operácia, a~preto sa hodí ju takisto vykonávať vo~vedľajšom vlákne na~pozadí.

Poďme sa ešte pozrieť na~to, čo presne zahŕňa vyhodnocovanie jednej aukčnej ponuky. Prejdeme všetky ponúknuté sumy, nájdeme najvyššiu sumu a~užívateľ, ktorý ju ponúkol bude vyhlásený za~víťaza. Víťaz aukcie bude informovaný o~skutočnoti, že vyhral stroj v~aukcii. Porazení budú takisto oboznámení o~svojej prehre. Okrem tohto scenára existuje ešte jeden. Čo ak sa nikto nezapojil do~aukcie? Má sa aukčná ponuka zmazať? Alebo iba označiť za~ukončnenú a~schovať sa pred~bežnými zákazníkmi? Alebo sa má koniec aukcie presunúť na~neskôr? Ako vidíme možností je viacero. Prvé dve možnosti vyžadujú zásah admina, ktorý by musel nanovo vložiť ponuku do systému~(prvý prípad) alebo~upraviť ponuku a~znova ju zviditeľniť zákazníkom~(druhý prípad). Všimnime si, že posledná z~možností nevyžaduje akciu admina. Administrátor môže ponuku upraviť, ale nemusí. Systém sa postará sám o~seba a~funguje aj bez~zásahu admina. A~to je presne to, čo od~nás vyžuje P3. Preto volíme tretí prístup. V~prípade, že aukcia skončí bez~víťaza, tak systém o~tom upozorní administrátora a~koniec ponuky posunie na~neskôr~(napr. o~týždeň).

V~oboch prípadoch (odpočet i~vyhodnocovanie) sme sa rozhodli využiť vlákna na~pozadí. Vo~frameworku Blazor existuje trieda~\verb|BackgroundService|\footnote{\url{https://learn.microsoft.com/en-us/aspnet/core/fundamentals/host/hosted-services?view=aspnetcore-7.0&tabs=visual-studio\#backgroundservice-base-class}}. Tá nám umožní rozbehnúť kód na~pozadí. Takže logiku behu vlákien na~pozadí si nemusíme implementovať sami.

\section{Posielanie a prijímanie správ}

Z pozorovania autor vie, že zákazníci týchto firiem, a rovnako i samotné firmy, sú zvyknuté na komunikáciu pomocou emailov.

V~predchádzajúcom texte sme už viackrát spomínali, že budeme posielať správy. Jednak kvôli spĺneniu P6, ale takisto pre~upozorňovanie účastníkov a~administrátorov na~priebeh aukcií. Tiež sme si povedali, že správy nebudú reprezentované entitami v~databáze. Ako teda vyriešime túto úlohu? Ak bude posielanie správ~(dopytov, notifikácií z~aukcie) implementované prostredníctvom posielania emailov do~emailovej schránky firmy, tak ušetríme miesto v~databáze. To nám môže potenciálne znížiť náklady, čo je v~prospech~P2. Nevýhodou by však bolo, že administrátor by musel chodiť kontrolovať emaily mimo našu aplikáciu. Tejto nevýhody sa dokážeme zbaviť. A to tak, že vytvoríme zjednodušenú emailovú schránku priamo v~našej aplikácii. Týmto spôsobom docielime toho, že užívateľ vie odoslať správu z~nášho systému, náš systém vie odoslať správu o~stave aukcií, admin si ich v~našej aplikácii vie prečítať a reagovať na ne. Zároveň sa nestaráme o~ukladanie správ v databáze, takže šetríme úložisko. A~čo viac, zákazníci vedia kontaktovať firmu i~mimo nášho systému (keď zákazník pošle firme email z~miesta mimo nášho systému, admin si ho vie aj napriek tomu v~našej aplikácii prečítať).

Dospeli sme k~tomu, že nepotrebujeme správy len odosielať ale potrebujeme ich aj čítať. Ešte predtým, než si zvolíme spôsob akým budeme správy prijímať a~posielať, si poďme vybrať akú emailovú službu budeme využívať. Od~služby vyžadujeme, aby podporovala protokoly IMAP~(pre~prijímanie správ) a~SMTP~(pre~posielanie správ). Jednou zo~služieb ktorá spĺňa podmienku je Gmail od~spoločnosti Google. Ide o~veľkú spoločnosť, ktorú pozná snáď každý a~autor dôveruje ich zabezpečeniu. Ďalším plusom je to, že k~tejto službe existuje dokumentácia. Navyše služba poskytuje API~(z~ang. application programming interface), ktoré by sme mohli využiť v~prípade potreby. Čítateľ by mohol poznamenať, že API by sme mohli vyyužiť ku~kompletnej implementácii našej schránky. Dôvodom prečo nevyužijeme API služby pre~kompletnú implementáciu je ten, že to čo ideme vytvoriť sa skôr podobá emailovému klientovi. Na~jeho implemenáciu je vhodnejšie použiť protokoly~IMAP a~SMTP ~(rovnako to spomína i~dokumentácia API\footnote{\url{https://developers.google.com/gmail/api/guides}}). Ako vidíme, Gmail sa zdá byť dobrým kandidátom, a~preto si ho zvolíme.

Ďalej potrebujeme zistiť ako môžeme využívať protokoly IMAP a~SMTP z~nášho programu. Zdá sa, že najznámejšími balíčkami pre~prácu s~týmito protokolmi sú MailKit a~AE.Net.Mail. Obe umožňujú prácu s~IMAP i~SMTP, ale AE.Net.Mail nebol už dlhšiu dobu aktualizovaný. A~preto, ak sa z~tohto systému stane dlhodobejší projekt, sa zdá byť lepšou možnosťou MailkKit.

\subsection{Automaticky generované správy}

Spomínali sme, že systém bude sám automaticky odosielať správy, či už víťazom aukcie, porazeným alebo~adminom, o~stave aukcie. Ak by náš systém využívali viaceré firmy, je prirodzené, že by si chceli tvar automaticky generovaných správ upraviť. Náš~systém firmám túto funkcionalitu umožní. Preto sme si v~časti~Návrh~relačného~modelu~datábazy~(\ref{navrh relacneho modelu databazy}) dopredu pripravili entitu reprezentujúcu automaticky generované správy.

%\section{Ďalší kód tretích strán}
%TBA? (Fontawesome, Syncfusion) + pridať že management treba na zaciatok %analyzy (ako do db sa daju veci? Treba inteface pre adminov!)

%\section{GDPR}
%TBA?
